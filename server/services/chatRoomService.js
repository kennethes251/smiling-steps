/**
 * ChatRoomService - Centralized Chat Room Management
 * 
 * This service handles all chat room operations including:
 * - Room creation with owner assignment
 * - Room listing and discovery
 * - Join/leave functionality
 * - Room settings management
 * 
 * Requirements: 1.1, 1.2, 1.3, 1.5, 1.6, 2.1, 2.2, 2.3, 2.5, 2.6, 5.1, 5.2, 5.3, 5.4, 6.1
 */

const ChatRoom = require('../models/ChatRoom');
const User = require('../models/User');
const mongoose = require('mongoose');

/**
 * Error codes for chat room operations
 */
const ERROR_CODES = {
  ROOM_NOT_FOUND: 'ROOM_NOT_FOUND',
  ROOM_FULL: 'ROOM_FULL',
  ROOM_CLOSED: 'ROOM_CLOSED',
  USER_BANNED: 'USER_BANNED',
  USER_NOT_PARTICIPANT: 'NOT_PARTICIPANT',
  USER_ALREADY_PARTICIPANT: 'ALREADY_PARTICIPANT',
  NOT_OWNER: 'NOT_OWNER',
  NOT_MODERATOR: 'NOT_MODERATOR',
  INVALID_ROOM_TYPE: 'INVALID_ROOM_TYPE',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  PRIVATE_ROOM_NO_INVITATION: 'PRIVATE_ROOM_NO_INVITATION',
  INVALID_PARTICIPANT_LIMIT: 'INVALID_PARTICIPANT_LIMIT'
};

/**
 * Valid room types
 */
const ROOM_TYPES = ['support_group', 'therapy_group', 'community', 'private'];

/**
 * ChatRoomService Class
 * 
 * Centralizes all chat room operations
 */
class ChatRoomService {
  
  /**
   * Create a new chat room
   * 
   * Requirements: 1.1, 1.2, 1.3, 1.5, 1.6
   * 
   * @param {string} ownerId - ID of the user creating the room (psychologist or admin)
   * @param {Object} roomData - Room configuration data
   * @param {string} roomData.name - Room name (required)
   * @param {string} roomData.description - Room description (required)
   * @param {string} roomData.roomType - Room type (required)
   * @param {Object} roomData.settings - Optional room settings
   * @returns {Promise<Object>} Created room
   * @throws {Error} If validation fails or user not authorized
   */
  async createRoom(ownerId, roomData) {
    // Validate required fields - Requirement 1.2
    if (!roomData.name || !roomData.name.trim()) {
      throw this._createError('Room name is required', ERROR_CODES.VALIDATION_ERROR, 400);
    }
    
    if (!roomData.description || !roomData.description.trim()) {
      throw this._createError('Room description is required', ERROR_CODES.VALIDATION_ERROR, 400);
    }
    
    if (!roomData.roomType) {
      throw this._createError('Room type is required', ERROR_CODES.VALIDATION_ERROR, 400);
    }
    
    // Validate room type
    if (!ROOM_TYPES.includes(roomData.roomType)) {
      throw this._createError(
        `Invalid room type. Must be one of: ${ROOM_TYPES.join(', ')}`,
        ERROR_CODES.INVALID_ROOM_TYPE,
        400
      );
    }
    
    // Validate owner exists and has appropriate role
    const owner = await User.findById(ownerId);
    if (!owner) {
      throw this._createError('Owner not found', ERROR_CODES.VALIDATION_ERROR, 404);
    }
    
    // Only psychologists and admins can create rooms - Requirement 1.1
    if (!['psychologist', 'admin'].includes(owner.role)) {
      throw this._createError(
        'Only psychologists and admins can create chat rooms',
        ERROR_CODES.VALIDATION_ERROR,
        403
      );
    }
    
    // Validate settings if provided
    const settings = this._validateSettings(roomData.settings || {});
    
    // Create the room - Requirement 1.3 (unique ID generated by MongoDB)
    const room = new ChatRoom({
      name: roomData.name.trim(),
      description: roomData.description.trim(),
      roomType: roomData.roomType,
      owner: ownerId,
      settings: settings,
      // Owner is automatically added as participant via pre-save middleware
      moderators: [ownerId] // Owner is also a moderator
    });
    
    await room.save();
    
    // Populate owner info for response
    await room.populate('owner', 'name email profilePicture role');
    
    console.log(`✅ ChatRoom created: ${room.name} (${room._id}) by ${owner.name}`);
    
    return room;
  }
  
  /**
   * Create a room with a designated owner (admin only)
   * 
   * Requirement 1.5: Admin can designate any psychologist as owner
   * 
   * @param {string} adminId - ID of the admin creating the room
   * @param {string} designatedOwnerId - ID of the psychologist to be owner
   * @param {Object} roomData - Room configuration data
   * @returns {Promise<Object>} Created room
   */
  async createRoomWithDesignatedOwner(adminId, designatedOwnerId, roomData) {
    // Verify admin role
    const admin = await User.findById(adminId);
    if (!admin || admin.role !== 'admin') {
      throw this._createError(
        'Only admins can designate room owners',
        ERROR_CODES.VALIDATION_ERROR,
        403
      );
    }
    
    // Verify designated owner is a psychologist
    const designatedOwner = await User.findById(designatedOwnerId);
    if (!designatedOwner) {
      throw this._createError('Designated owner not found', ERROR_CODES.VALIDATION_ERROR, 404);
    }
    
    if (designatedOwner.role !== 'psychologist') {
      throw this._createError(
        'Designated owner must be a psychologist',
        ERROR_CODES.VALIDATION_ERROR,
        400
      );
    }
    
    // Create room with designated owner
    return this.createRoom(designatedOwnerId, roomData);
  }

  
  /**
   * List public/community rooms for discovery
   * 
   * Requirements: 2.1, 2.6
   * 
   * @param {Object} options - Query options
   * @param {number} options.limit - Max rooms to return (default 20)
   * @param {number} options.skip - Offset for pagination (default 0)
   * @param {string} options.search - Search term for room name/description
   * @param {string} options.roomType - Filter by room type
   * @returns {Promise<Object>} List of rooms with pagination info
   */
  async listPublicRooms(options = {}) {
    const { limit = 20, skip = 0, search, roomType } = options;
    
    // Build query for public/community rooms - Requirement 2.1
    const query = {
      isActive: true,
      $or: [
        { 'settings.isPublic': true },
        { roomType: 'community' }
      ]
    };
    
    // Filter by room type if specified
    if (roomType && ROOM_TYPES.includes(roomType)) {
      query.roomType = roomType;
    }
    
    let findQuery;
    
    // Handle text search
    if (search && search.trim()) {
      findQuery = ChatRoom.find({
        ...query,
        $text: { $search: search.trim() }
      })
      .select('name description roomType owner participants settings lastActivity messageCount createdAt')
      .populate('owner', 'name profilePicture')
      .sort({ score: { $meta: 'textScore' }, lastActivity: -1 });
    } else {
      findQuery = ChatRoom.find(query)
        .select('name description roomType owner participants settings lastActivity messageCount createdAt')
        .populate('owner', 'name profilePicture')
        .sort({ lastActivity: -1 });
    }
    
    // Get total count for pagination
    const total = await ChatRoom.countDocuments(query);
    
    // Execute query with pagination
    const rooms = await findQuery.skip(skip).limit(limit);
    
    // Transform rooms to include participant count - Requirement 2.6
    const roomsWithCount = rooms.map(room => ({
      _id: room._id,
      name: room.name,
      description: room.description,
      roomType: room.roomType,
      owner: room.owner,
      participantCount: room.participants ? room.participants.length : 0,
      maxParticipants: room.settings?.maxParticipants || 50,
      isJoinable: room.settings?.isJoinable !== false,
      lastActivity: room.lastActivity,
      messageCount: room.messageCount,
      createdAt: room.createdAt
    }));
    
    return {
      rooms: roomsWithCount,
      pagination: {
        total,
        limit,
        skip,
        hasMore: skip + rooms.length < total
      }
    };
  }
  
  /**
   * Get rooms for a specific user
   * 
   * @param {string} userId - User ID
   * @returns {Promise<Array>} List of user's rooms
   */
  async getUserRooms(userId) {
    const rooms = await ChatRoom.find({
      isActive: true,
      'participants.user': userId
    })
    .select('name description roomType owner participants settings lastActivity messageCount createdAt')
    .populate('owner', 'name profilePicture')
    .sort({ lastActivity: -1 });
    
    return rooms.map(room => {
      const participant = room.participants.find(
        p => p.user.toString() === userId.toString()
      );
      
      return {
        _id: room._id,
        name: room.name,
        description: room.description,
        roomType: room.roomType,
        owner: room.owner,
        participantCount: room.participants.length,
        myRole: participant?.role || 'participant',
        lastActivity: room.lastActivity,
        messageCount: room.messageCount,
        joinedAt: participant?.joinedAt,
        notificationsEnabled: participant?.notificationsEnabled !== false
      };
    });
  }
  
  /**
   * Get room by ID with full details
   * 
   * @param {string} roomId - Room ID
   * @param {string} userId - Requesting user ID (for permission check)
   * @returns {Promise<Object>} Room details
   */
  async getRoomById(roomId, userId = null) {
    const room = await ChatRoom.findById(roomId)
      .populate('owner', 'name email profilePicture role')
      .populate('moderators', 'name profilePicture')
      .populate('participants.user', 'name profilePicture');
    
    if (!room) {
      throw this._createError('Room not found', ERROR_CODES.ROOM_NOT_FOUND, 404);
    }
    
    // For private rooms, check if user is a participant
    if (room.roomType === 'private' && userId) {
      if (!room.isParticipant(userId) && !room.isOwner(userId)) {
        throw this._createError(
          'You do not have access to this private room',
          ERROR_CODES.USER_NOT_PARTICIPANT,
          403
        );
      }
    }
    
    return room;
  }

  
  /**
   * Join a chat room
   * 
   * Requirements: 2.2, 2.3, 2.5
   * 
   * @param {string} roomId - Room ID
   * @param {string} userId - User ID
   * @returns {Promise<Object>} Updated room
   */
  async joinRoom(roomId, userId) {
    const room = await ChatRoom.findById(roomId);
    
    if (!room) {
      throw this._createError('Room not found', ERROR_CODES.ROOM_NOT_FOUND, 404);
    }
    
    if (!room.isActive) {
      throw this._createError('Room is no longer active', ERROR_CODES.ROOM_CLOSED, 400);
    }
    
    // Check if room is joinable - Requirement 5.3
    if (!room.settings.isJoinable) {
      throw this._createError(
        'Room is not accepting new members',
        ERROR_CODES.ROOM_CLOSED,
        400
      );
    }
    
    // Check if user is banned - Requirement 2.5
    if (room.isBanned(userId)) {
      throw this._createError(
        'You are banned from this room',
        ERROR_CODES.USER_BANNED,
        403
      );
    }
    
    // Check if already a participant
    if (room.isParticipant(userId)) {
      throw this._createError(
        'You are already a participant in this room',
        ERROR_CODES.USER_ALREADY_PARTICIPANT,
        400
      );
    }
    
    // Check participant limit - Requirement 2.3
    if (room.participants.length >= room.settings.maxParticipants) {
      throw this._createError(
        'Room has reached maximum participant limit',
        ERROR_CODES.ROOM_FULL,
        400
      );
    }
    
    // For private rooms, check invitation - Requirement 1.4
    if (room.roomType === 'private') {
      const hasValidInvitation = room.invitations.some(
        inv => inv.user.toString() === userId.toString() &&
               inv.status === 'pending' &&
               (!inv.expiresAt || inv.expiresAt > new Date())
      );
      
      if (!hasValidInvitation) {
        throw this._createError(
          'Private rooms require an invitation to join',
          ERROR_CODES.PRIVATE_ROOM_NO_INVITATION,
          403
        );
      }
      
      // Mark invitation as accepted
      const invitation = room.invitations.find(
        inv => inv.user.toString() === userId.toString() && inv.status === 'pending'
      );
      if (invitation) {
        invitation.status = 'accepted';
      }
    }
    
    // Add participant - Requirement 2.2
    room.addParticipant(userId, 'participant');
    room.updateActivity();
    
    await room.save();
    
    // Populate for response
    await room.populate('participants.user', 'name profilePicture');
    
    console.log(`✅ User ${userId} joined room ${room.name} (${room._id})`);
    
    return room;
  }
  
  /**
   * Leave a chat room
   * 
   * Requirement 6.1
   * 
   * @param {string} roomId - Room ID
   * @param {string} userId - User ID
   * @returns {Promise<Object>} Updated room or null if room was deleted
   */
  async leaveRoom(roomId, userId) {
    const room = await ChatRoom.findById(roomId);
    
    if (!room) {
      throw this._createError('Room not found', ERROR_CODES.ROOM_NOT_FOUND, 404);
    }
    
    // Check if user is a participant
    if (!room.isParticipant(userId)) {
      throw this._createError(
        'You are not a participant in this room',
        ERROR_CODES.USER_NOT_PARTICIPANT,
        400
      );
    }
    
    // Handle owner leaving - Requirement 5.6
    if (room.isOwner(userId)) {
      return this._handleOwnerLeave(room, userId);
    }
    
    // Remove participant - Requirement 6.1
    room.removeParticipant(userId);
    room.updateActivity();
    
    await room.save();
    
    console.log(`✅ User ${userId} left room ${room.name} (${room._id})`);
    
    return room;
  }
  
  /**
   * Handle owner leaving the room
   * 
   * Requirement 5.6: Transfer ownership or close room
   * 
   * @param {Object} room - Room document
   * @param {string} ownerId - Owner ID
   * @returns {Promise<Object|null>} Updated room or null if closed
   * @private
   */
  async _handleOwnerLeave(room, ownerId) {
    // Find the oldest moderator (excluding owner)
    const moderatorParticipants = room.participants
      .filter(p => 
        p.user.toString() !== ownerId.toString() &&
        (p.role === 'moderator' || room.moderators.some(m => m.toString() === p.user.toString()))
      )
      .sort((a, b) => a.joinedAt - b.joinedAt);
    
    if (moderatorParticipants.length > 0) {
      // Transfer ownership to oldest moderator
      const newOwner = moderatorParticipants[0];
      
      room.owner = newOwner.user;
      newOwner.role = 'owner';
      
      // Remove old owner from participants
      room.removeParticipant(ownerId);
      room.updateActivity();
      
      await room.save();
      
      console.log(`✅ Ownership of room ${room.name} transferred to ${newOwner.user}`);
      
      return room;
    } else {
      // No moderators available - check for any other participants
      const otherParticipants = room.participants
        .filter(p => p.user.toString() !== ownerId.toString())
        .sort((a, b) => a.joinedAt - b.joinedAt);
      
      if (otherParticipants.length > 0) {
        // Transfer to oldest participant
        const newOwner = otherParticipants[0];
        
        room.owner = newOwner.user;
        newOwner.role = 'owner';
        room.moderators.push(newOwner.user);
        
        room.removeParticipant(ownerId);
        room.updateActivity();
        
        await room.save();
        
        console.log(`✅ Ownership of room ${room.name} transferred to participant ${newOwner.user}`);
        
        return room;
      } else {
        // No other participants - archive the room
        room.isActive = false;
        room.removeParticipant(ownerId);
        
        await room.save();
        
        console.log(`✅ Room ${room.name} archived - owner left with no other participants`);
        
        return null;
      }
    }
  }

  
  /**
   * Update room settings
   * 
   * Requirements: 5.1, 5.2, 5.3, 5.4
   * 
   * @param {string} roomId - Room ID
   * @param {string} userId - User ID (must be owner)
   * @param {Object} updates - Settings to update
   * @returns {Promise<Object>} Updated room
   */
  async updateRoomSettings(roomId, userId, updates) {
    const room = await ChatRoom.findById(roomId);
    
    if (!room) {
      throw this._createError('Room not found', ERROR_CODES.ROOM_NOT_FOUND, 404);
    }
    
    // Only owner can update settings
    if (!room.isOwner(userId)) {
      throw this._createError(
        'Only the room owner can update settings',
        ERROR_CODES.NOT_OWNER,
        403
      );
    }
    
    // Validate and apply settings updates
    const validatedSettings = this._validateSettings(updates);
    
    // Update room name if provided
    if (updates.name !== undefined) {
      if (!updates.name || !updates.name.trim()) {
        throw this._createError('Room name cannot be empty', ERROR_CODES.VALIDATION_ERROR, 400);
      }
      room.name = updates.name.trim();
    }
    
    // Update description if provided
    if (updates.description !== undefined) {
      room.description = updates.description ? updates.description.trim() : '';
    }
    
    // Apply settings - Requirement 5.1 (changes apply immediately)
    if (validatedSettings.maxParticipants !== undefined) {
      // Requirement 5.2: Validate bounds (1-100)
      room.settings.maxParticipants = validatedSettings.maxParticipants;
    }
    
    if (validatedSettings.isJoinable !== undefined) {
      // Requirement 5.3: Toggle joinable
      room.settings.isJoinable = validatedSettings.isJoinable;
    }
    
    if (validatedSettings.isPublic !== undefined) {
      // Requirement 5.4: Toggle visibility
      room.settings.isPublic = validatedSettings.isPublic;
    }
    
    if (validatedSettings.messageRetentionDays !== undefined) {
      room.settings.messageRetentionDays = validatedSettings.messageRetentionDays;
    }
    
    if (validatedSettings.allowFileSharing !== undefined) {
      room.settings.allowFileSharing = validatedSettings.allowFileSharing;
    }
    
    room.updateActivity();
    await room.save();
    
    console.log(`✅ Room settings updated for ${room.name} (${room._id})`);
    
    return room;
  }
  
  /**
   * Update room basic info (name, description)
   * 
   * @param {string} roomId - Room ID
   * @param {string} userId - User ID (must be owner)
   * @param {Object} updates - Updates to apply
   * @returns {Promise<Object>} Updated room
   */
  async updateRoom(roomId, userId, updates) {
    return this.updateRoomSettings(roomId, userId, updates);
  }
  
  /**
   * Delete/archive a room
   * 
   * @param {string} roomId - Room ID
   * @param {string} userId - User ID (must be owner or admin)
   * @returns {Promise<Object>} Archived room
   */
  async deleteRoom(roomId, userId) {
    const room = await ChatRoom.findById(roomId);
    
    if (!room) {
      throw this._createError('Room not found', ERROR_CODES.ROOM_NOT_FOUND, 404);
    }
    
    // Check if user is owner
    const user = await User.findById(userId);
    const isOwner = room.isOwner(userId);
    const isAdmin = user && user.role === 'admin';
    
    if (!isOwner && !isAdmin) {
      throw this._createError(
        'Only the room owner or admin can delete the room',
        ERROR_CODES.NOT_OWNER,
        403
      );
    }
    
    // Soft delete - archive the room
    room.isActive = false;
    await room.save();
    
    console.log(`✅ Room ${room.name} (${room._id}) archived by ${userId}`);
    
    return room;
  }
  
  /**
   * Get room participants
   * 
   * @param {string} roomId - Room ID
   * @returns {Promise<Array>} List of participants
   */
  async getParticipants(roomId) {
    const room = await ChatRoom.findById(roomId)
      .populate('participants.user', 'name email profilePicture role')
      .populate('owner', 'name profilePicture');
    
    if (!room) {
      throw this._createError('Room not found', ERROR_CODES.ROOM_NOT_FOUND, 404);
    }
    
    return room.participants.map(p => ({
      user: p.user,
      role: p.role,
      joinedAt: p.joinedAt,
      isMuted: room.isMuted(p.user._id),
      mutedUntil: p.mutedUntil,
      isOwner: room.isOwner(p.user._id),
      isModerator: room.isModerator(p.user._id)
    }));
  }
  
  /**
   * Validate room settings
   * 
   * @param {Object} settings - Settings to validate
   * @returns {Object} Validated settings
   * @private
   */
  _validateSettings(settings) {
    const validated = {};
    
    // Validate maxParticipants - Requirement 5.2
    if (settings.maxParticipants !== undefined) {
      const max = parseInt(settings.maxParticipants, 10);
      if (isNaN(max) || max < 1 || max > 100) {
        throw this._createError(
          'Participant limit must be between 1 and 100',
          ERROR_CODES.INVALID_PARTICIPANT_LIMIT,
          400
        );
      }
      validated.maxParticipants = max;
    }
    
    // Validate boolean settings
    if (settings.isJoinable !== undefined) {
      validated.isJoinable = Boolean(settings.isJoinable);
    }
    
    if (settings.isPublic !== undefined) {
      validated.isPublic = Boolean(settings.isPublic);
    }
    
    if (settings.allowFileSharing !== undefined) {
      validated.allowFileSharing = Boolean(settings.allowFileSharing);
    }
    
    // Validate messageRetentionDays
    if (settings.messageRetentionDays !== undefined) {
      const days = parseInt(settings.messageRetentionDays, 10);
      if (isNaN(days) || days < 1) {
        throw this._createError(
          'Message retention days must be at least 1',
          ERROR_CODES.VALIDATION_ERROR,
          400
        );
      }
      validated.messageRetentionDays = days;
    }
    
    return validated;
  }
  
  /**
   * Create a standardized error object
   * 
   * @param {string} message - Error message
   * @param {string} code - Error code
   * @param {number} status - HTTP status code
   * @returns {Error} Error object
   * @private
   */
  _createError(message, code, status = 400) {
    const error = new Error(message);
    error.code = code;
    error.status = status;
    return error;
  }
}

// Export singleton instance
const chatRoomService = new ChatRoomService();

module.exports = {
  ChatRoomService,
  chatRoomService,
  ERROR_CODES,
  ROOM_TYPES
};
